/* description: Parses end executes mathematical expressions. */

/* lexical grammar */
%lex
%%

\s+                   	/* skip whitespace */
[0-9]+("."[0-9]+)?\b  	return 'NUMBER'
\"([^\"]+)\"          	return 'STRING'
"+"                   	return '+'
"."                   	return 'DOT'
"("                   	return '('
")"                   	return ')'
"or"                  	return 'OR'
"and"                 	return 'AND'
"implies" 		return 'IMPLIES'
"->"[a-zA-Z]+           return 'FUNCTIONCALL'
<<EOF>>               	return 'EOF'
"("([a-zA-Z0-9]","?)+)  

[a-zA-Z]+            	return 'VAR'
"\.([a-zA-Z]+)"      	return 'ATTRIBUTE'
{int}{frac}?{exp}?\b 	return 'NUMBER'
/lex

/* operator associations and precedence */

%left '+'
%left 'IMPLIES'
%left 'AND'

%left 'OR'
%left 'DOT'
%left 'FUNCTIONCALL'


%start expressions

%% /* language grammar */

expressions
    : e EOF               {return $1;}
    ;

e
    : e '+' e              	{$$ = $1+$3;}
    | e 'DOT' e            	{$$ = "DotExpression(VariableExpression(" + $1 + "), AttributeCallExpression(" + $3 + "))";}
    | '(' e ')'            	{$$ = $2;}
    | NUMBER               	{$$ = Number(yytext);}
    | STRING               	{$$ = JSON.parse($1);}
    | VAR                  	{$$ = $1;}
    | ATTRIBUTE            	{$$ = $1;}
    | e 'IMPLIES' e        	{$$ = "ImpliesExpression(" + $1 + ", " + $3 + ")";}
    | e 'OR' e              	{$$ = "OrExpression(" + $1 + "," + $3 + ")";}
    | e 'AND' e              	{$$ = "AndExpression(" + $1 + "," + $3 + ")";}
    | e 'FUNCTIONCALL' fn        {$$ = $2 + "sad" + $1}
    ;

fn
    : 'FORALL'                  {$$ = $1}